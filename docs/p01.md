# Project 1 - Alarm Clock

## Instructions
Your submission should include a design document that describes key design decisions that
you made in your system. The document should be located at docs/p01.md. Your design
document should include a separate section for each of the two other tasks (shell and alarm
clock). For each section, you should outline (1) any data structures that you created or
extended in your design (note: you can specify N/A if you do not create any); (2) any
algorithms that you created for your design; (3) any synchronization used in your design;
and (4) a justification of your design. You should aim to have enough detail in your design
that a fellow 134 student would be capable of re-implementing your system by following it.

1) Data structures created/extended
2) algorithms
3) synchronization
4) Justification

## Shell
### 1) Data structures created/extended

All changes were made in init.c, where I extended upon the pintos_init() function.

I put the basic shell functionality into its own function called run_shell(), as to encourage more modularity. 

In addition I created a helper function called check_command() to check a certain inputted command, which helped made the code more concise and easier to debug.

I have primarily used char pointer arrays to store the inputted string into a buffer. Also used many loops to iterate through each input and to cycle shell output.


### 2) Algorithms

The first loop in the shell always runs unless the exit command is inputted. The inner loop keeps iterating through each inputted character.

To get input from the user, I used the input_getc() command to get each inputted character and concatenated it to a buffer. For each inputted key it checks for a return character, then exiting a inner loop and parsing the newly generated string buffer. 

To parse the string and check for commands, I used a tokenizing algorithm in the function check_command() to check whether the first command was indeed the exit or whoami command, otherwise return invalid command.

### 3) Synchronization

No synchronization was used. The strtok_r() function was used however, as it is multi-thread safe.

### 4) Justification
The pintos_init() function was modified, since it is the Pintos main entry point when running ```pintos -- [etc]```. Code was added near the end of the function at the TODO else statement, where no command line arguements were passed.

The input_getc() function was used since it provided a convenient way to take character input. I used a buffer to store the string, similarly as to what was done in cse130.

The check_command() function checks if the first command was one of the target commands. As my idea was that reading the exit command should automatically ignore any flags, etc as it inherently means to exit the shell.

## Alarm clock


### 1) Data structures created/extended
All code changes were made in timer.c, minus adding a int64_t ticks_to_sleep variable in thread.h to store the thread's tick count/time.

I extended the timer_init() function to initialize a list of threads.

I obviously modified the timer_sleep function as to not busy-wait, handling setting and comparing tick values, interrupts, and blocking that is implemented in other functions.

Also extended the timer_interrupt() function to do thread tick calculations and handle thread unblocking.

I added a function called is_less_than() that returns a bool value as to whether list element is less than the other -- used for list_insert_ordered().

### 2) Algorithms

I referenced the thread sort algorithm from https://github.com/Ma06RC/Pintos-Busy-Wait , where their algorithm inspired the design in my code. Where when putting the current thread into a list of threads(in timer_sleep()), it would be ordered from least to greatest ticks, allowing a more efficient way of awakening threads.

When the timer_interrupt() function gets called, it will then cycle through the thread list, unblocking and popping each thread that has fully elasped its tick timer -- with the loop ending once the size of the list is zero. 

The check for whether the thread's tick timer has elasped is seen in the if statement below for timer_interrupt()

#### from timer_sleep()
```
  // get current thread
  struct thread *t = thread_current();

  // store the time for when the thread should awaken
  t->ticks_to_sleep = timer_ticks() + ticks;
  
  // disabling interrupts so can block threads
  enum intr_level old_level = intr_disable();
  // insert the list in an ordered fashion, from lib/kernel/list.h
  list_insert_ordered(&list_threads, &t->elem, is_less_than, NULL);
  thread_block();
  // set interrupts back to the previous level
  intr_set_level(old_level);
```

#### from timer_interrupt()
```
  while(list_size(&list_threads)) {
    // get thread in front of list
    t = list_entry(list_front(&list_threads), struct thread, elem);
    
    // check if enough time has elapsed to unblock the thread
    if (timer_ticks() < t->ticks_to_sleep) {
      break;
    }
    
    list_pop_front(&list_threads);
    thread_unblock(t);
  }
```

### 3) Synchronization
For synchronization, I implemented unblocking threads in in timer_interrupt(), where it cycles through the first thread with the shortest timer, and once expired it would unblock the thread and go on to check the next.

The current thread is blocked after it gets inserted into the list of threads.

I also disabled interrupts when inserting each thread into a list in order, and re-enabling it after the thread_block() statement so as to ensure interrupts are still existent.

### 4) Justification

The use of a sorted thread list was a main design choice, as other implementations would cycle through every thread arbitrarily using PintOS's thread_foreach() function -- being way less efficient in regards to unblocking the earliest threads.

Disabling the interrupt in timer_sleep() temporarily was done to ensure inserting the thread into the list was executed one after the other without interruption, since this is indeed a multi-threaded environment.

