# Project 1 - Alarm Clock

## Instructions
Your submission should include a design document that describes key design decisions that
you made in your system. The document should be located at docs/p01.md. Your design
document should include a separate section for each of the two other tasks (shell and alarm
clock). For each section, you should outline (1) any data structures that you created or
extended in your design (note: you can specify N/A if you do not create any); (2) any
algorithms that you created for your design; (3) any synchronization used in your design;
and (4) a justification of your design. You should aim to have enough detail in your design
that a fellow 134 student would be capable of re-implementing your system by following it.

1) Data structures created/extended
2) algorithms
3) synchronization
4) Justification

## Shell
### 1) Data structures created/extended

All changes were made in init.c, where I extended upon the pintos_init() function.

I put the basic shell functionality into its own function called run_shell(), as to encourage more modularity. 

In addition I created a helper function called check_command() to check a certain inputted command, which helped made the code more concise and easier to debug.

I have primarily used char pointer arrays to store the inputted string into a buffer. Also used many loops to iterate through each input and to cycle shell output.

The first loop in the shell always runs unless the exit command is inputted. The inner loop keeps iterating through each inputted character.

### 2) Algorithms

To get input from the user, I used the input_getc() command to get each inputted character and concatenated it to a buffer. For each inputted key it checks for a return character, then exiting a inner loop and parsing the newly generated string buffer. To parse the string and check for commands, I used a tokenizing algorithm to check whether the first command was indeed the exit or whoami command, otherwise return invalid command.

### 3) Synchronization

No synchronization was used. The strtok_r() function was used however, as it is multi-thread safe.

### 4) Justification
The pintos_init() function was modified, since it is the Pintos main entry point when running ```pintos -- [etc]```. Code was added near the end of the function at the TODO else statement, where no command line arguements were passed.

The input_getc() function was used since it provided a convenient way to take character input. I used a buffer to store the string, similarly as to what was done in cse130.

The check_command() function checks if the first command was one of the target commands. As my idea was that reading the exit command should automatically ignore any flags, etc as it inherently means to exit the shell.

## Alarm clock

1) 
