Your design
document should include a separate section for each of the four other tasks (argument parsing, system calls, process termination message, and user memory). 

For each section, you should outline 
(1) any data structures that you created or extended in your design; 
(2) any algorithms that you created for your design; 
(3) any synchronization used in your design;
(4) a justification of your design (Why is it correct? Why is it fast? etc.).


You should aim to have enough detail in your design that a fellow 134 student would be capable of re-implementing your system by following it. Note: if your design does not require any of these features (e.g., you do not have data structures for the process termination message)
specify “N/A”.


# Project 2

## Argument Parsing

### 1) Data structures created/extended
### 2) Algorithms
### 3) Synchronization
### 4) Justification



## System Calls

### 1) Data structures created/extended

Since many system calls deal with locating and processing files, we created a struct called file_inst (file instance) that stores the file pointer, file descriptor, and the file's list element -- using the PintOS provided list data structures. Along with a corresponding struct generating helper function that importantly locates the file from its file descriptor.

Regarding the list data structure, these are initialized in the thread's init() function.

#### from syscall.h
```
struct file_inst
{
  // set file pointer
  struct file * file_p;
  // file descriptor
  int fd;
  // list element
  struct list_elem file_list_e;
};
```

#### from syscall.c
```
struct file_inst *locate_file (int fd) {
  // get current thread
  struct thread * cur = thread_current();
  struct list_elem * list_e;

  // iterate through list of files until locate correct file descriptor element
  for (list_e = list_begin(&cur->list_files); list_e != list_end(&cur->list_files); list_e = list_next(list_e)) {
    struct file_inst * fd_e = list_entry(list_e, struct file_inst, file_list_e);
    if (fd_e->fd == fd) {
      return fd_e;
    }
  }

  debug_printf("locate_file(): returned NULL!\n");

  return NULL;
}
```

Side Note: we created a toggleable printf (debug_printf) to make our debugging lives easier.

### 2) Algorithms

As seen in the locate_file struct, it contains a relatively simple algorithm that essentially cycle's through the current thread's entire list of files until it locates the matching file descriptor element.

### 3) Synchronization

As for good practice, when ever doing any file reads/writes I added a lock to prevent race-conditions.

### 4) Justification

The reason for adding this file struct, is to conveniently serve as a getter function for the thread's files. As it was used in these syscalls: write, read, seek, filesize, tell, and close.

## Process Termination Message

### 1) Data structures created/extended

A big challenge during testing was the "bad-___" tests, where we encountered page faults.

We modifed the page_fault() function in exception.c, reusing the same thread-exit code that we implemented earlier in syscall's exit() function where we can correctly set an exit status of -1 to the thread, along with handling our own thread parent & child synchronization. The added code is near the bottom, where we commented out some stuff that PintOS provided.

#### From exception.c
```
static void
page_fault (struct intr_frame *f) 
{

  ...
  [shortened code]
  ...
  /* To implement virtual memory, delete the rest of the function
     body, and replace it with code that brings in the page to
     which fault_addr refers. */
  // printf ("Page fault at %p: %s error %s page in %s context.\n",
  //         fault_addr,
  //         not_present ? "not present" : "rights violation",
  //         write ? "writing" : "reading",
  //         user ? "user" : "kernel");
  
  thread_current()->exit_status = -1;
  thread_current()->parent->child_done = 1; 
  if(thread_current()->parent->child_waiting == thread_current()->tid){
    // If the parent thread is waiting on us, release them
    sema_up(&thread_current()->parent->sem_child_wait); 
  }
  
  thread_exit();
  // kill (f);
}

```



### 2) Algorithms
### 3) Synchronization
### 4) Justification

We decided on editing the exception.c file's page_fault() function, mainly because we spent hours trying other implementations that did not prevent these page files. In addition, the function's header comment literally states "Some Some solutions to project 2 may also require modifying this code."

## User Memory

### 1) Data structures created/extended
### 2) Algorithms
### 3) Synchronization
### 4) Justification
