Your design
document should include a separate section for each of the four other tasks (argument parsing, system calls, process termination message, and user memory). 

For each section, you should outline 
(1) any data structures that you created or extended in your design; 
(2) any algorithms that you created for your design; 
(3) any synchronization used in your design;
(4) a justification of your design (Why is it correct? Why is it fast? etc.).


You should aim to have enough detail in your design that a fellow 134 student would be capable of re-implementing your system by following it. Note: if your design does not require any of these features (e.g., you do not have data structures for the process termination message)
specify “N/A”.


# Project 2

## Argument Parsing

### 1) Data structures created/extended
### 2) Algorithms
### 3) Synchronization
### 4) Justification



## System Calls

### 1) Data structures created/extended

Since many system calls deal with locating and processing files, we created a struct called file_inst (file instance) that stores the file pointer, file descriptor, and the file's list element -- using the PintOS provided list data structures. Along with a corresponding struct generating helper function that importantly locates the file from its file descriptor.

Regarding the list data structure, these are initialized in the thread's init() function.

#### from syscall.h
```
struct file_inst
{
  // set file pointer
  struct file * file_p;
  // file descriptor
  int fd;
  // list element
  struct list_elem file_list_e;
};
```

#### from syscall.h
```
struct file_inst *locate_file (int fd) {
  // get current thread
  struct thread * cur = thread_current();
  struct list_elem * list_e;

  // iterate through list of files until locate correct file descriptor element
  for (list_e = list_begin(&cur->list_files); list_e != list_end(&cur->list_files); list_e = list_next(list_e)) {
    struct file_inst * fd_e = list_entry(list_e, struct file_inst, file_list_e);
    if (fd_e->fd == fd) {
      return fd_e;
    }
  }

  debug_printf("locate_file(): returned NULL!\n");

  return NULL;
}
```

Side Note: we created a toggleable printf (debug_printf) to make our debugging lives easier.

### 2) Algorithms

As seen in the locate_file struct, it contains a relatively simple algorithm that essentially cycle's through the current thread's entire list of files until it locates the matching file descriptor element.

### 3) Synchronization

As for good practice, when ever doing any file reads/writes I added a lock to prevent race-conditions.

### 4) Justification

The reason for adding this file struct, is to conveniently serve as a getter function for the thread's files. As it was used in these syscalls: write, read, seek, filesize, tell, and close.

## Process Termination Message

### 1) Data structures created/extended
### 2) Algorithms
### 3) Synchronization
### 4) Justification

## User Memory

### 1) Data structures created/extended
### 2) Algorithms
### 3) Synchronization
### 4) Justification
